trigger: none
pr:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'


variables:
- group: pythonrest-cli # This group likely contains pip_api_key, pypi_app_name
# GITHUB_REPO_OWNER and GITHUB_REPO_NAME will now be determined dynamically.
# These can be kept as fallbacks or for reference, but the script will prioritize dynamic values.
# - name: GITHUB_REPO_OWNER
#   value: 'your-github-username-or-org' # Fallback or reference
# - name: GITHUB_REPO_NAME
#   value: 'pythonrest' # Fallback or reference
# GITHUB_TOKEN will be a secret variable, configured in Azure DevOps UI

jobs:
- job: ExtractVersion
  displayName: '1. Extract Version & Prepare Files'
  pool:
    vmImage: ubuntu-latest
  steps:
  - checkout: self # Checks out the repository
    persistCredentials: true # Important for git operations if needed later, and for commit sha
  - script: |
      # Ensure we have full commit history in the CI environment
      git fetch --all --unshallow
      
      # Find the last non-merge commit before the merge commit (PR source commit)
      last_commit_message=$(git log -1 --pretty=%s $(git rev-list --no-merges -n 1 HEAD))

      if [[ $last_commit_message =~ version\ ?([0-9]+\.[0-9]+\.[0-9]+) ]]; then
        extracted_version="${BASH_REMATCH[1]}"
        echo "Extracted version from commit message: $extracted_version"
      else
        echo "Commit message does not contain version format (version X.X.X)."
        echo "Last commit message: $last_commit_message"
        echo "Using fallback: extracting current version from setup.py and incrementing patch version for testing"
        
        # Extract current version from setup.py
        current_version=$(grep -oP "version='\K[0-9]+\.[0-9]+\.[0-9]+" ./setup.py)
        echo "Current version in setup.py: $current_version"
        
        # Split version into parts and increment patch version
        IFS='.' read -r major minor patch <<< "$current_version"
        new_patch=$((patch + 1))
        extracted_version="${major}.${minor}.${new_patch}"
        echo "Generated test version: $extracted_version"
      fi
      
      # Set the output variable for this job, accessible by other jobs in the same stage
      echo "##vso[task.setvariable variable=packageVersion;isOutput=true]$extracted_version"

      sed -i "s/version='[0-9]\+\.[0-9]\+\.[0-9]\+'$/version='$extracted_version'/" ./setup.py
      sed -i "s/pythonrest_version = \"[0-9]\+\.[0-9]\+\.[0-9]\+\"/pythonrest_version = \"$extracted_version\"/" ./pythonrest.py
      
      echo "Updated setup.py and pythonrest.py version to $extracted_version"
      
      grep "version=" ./setup.py
      grep "pythonrest_version" ./pythonrest.py
    name: VersionExtractionStep # Step name to reference its output variable

- job: CreateGitHubRelease
  displayName: '2. Create GitHub Release'
  dependsOn: ExtractVersion
  pool:
    vmImage: ubuntu-latest
  variables:
    # Map the output variable from ExtractVersion job to a local variable in this job
    RELEASE_VERSION: $[ dependencies.ExtractVersion.outputs['VersionExtractionStep.packageVersion'] ]
    # GITHUB_TOKEN should be a secret pipeline variable (e.g., from a variable group or configured in UI)
    # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are defined at the pipeline level or can be overridden here/passed from group
  steps:
  - checkout: self # Checkout self to ensure git commands work, e.g. git rev-parse HEAD
    persistCredentials: true
  - script: |
      # Script to create a GitHub Release (from previous step)
      # Environment variables expected by this script:
      # GITHUB_TOKEN: (mapped from Azure Pipelines secret $(GITHUB_TOKEN))
      # VERSION: (this is mapped to $(RELEASE_VERSION) which comes from the previous job)
      # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are now determined dynamically within this script.

      echo "--- GitHub Release Script ---"
      echo "Version from previous job: $(RELEASE_VERSION)"
      
      # Debug: Check if GITHUB_TOKEN is available (without revealing the actual token)
      if [ -n "$GITHUB_TOKEN" ]; then
        echo "GITHUB_TOKEN is available (length: ${#GITHUB_TOKEN})"
      else
        echo "WARNING: GITHUB_TOKEN is not available or empty"
      fi
      
      # Get the commit message for the release body
      git fetch --all --unshallow
      last_commit_message=$(git log -1 --pretty=%s $(git rev-list --no-merges -n 1 HEAD))
      echo "Last commit message: $last_commit_message"

      # --- Determine Repository Owner and Name Dynamically ---
      REPO_FULL_NAME="$(Build.Repository.Name)" # e.g., "your-username/pythonrest"
      DYNAMIC_GITHUB_REPO_OWNER=""
      DYNAMIC_GITHUB_REPO_NAME=""

      if [[ "$(Build.Repository.Provider)" == "GitHub" && "$REPO_FULL_NAME" == */* ]]; then
        DYNAMIC_GITHUB_REPO_OWNER="${REPO_FULL_NAME%/*}"
        DYNAMIC_GITHUB_REPO_NAME="${REPO_FULL_NAME#*/}"
        echo "Dynamically determined GitHub Owner: $DYNAMIC_GITHUB_REPO_OWNER, Repo: $DYNAMIC_GITHUB_REPO_NAME"
      else
        echo "Error: Could not dynamically determine GitHub owner/repo. Provider: '$(Build.Repository.Provider)', Repo Name: '$REPO_FULL_NAME'."
        echo "Ensure pipeline is connected to a GitHub repository and checkout step ran."
        exit 1
      fi

      # --- Configuration (TEMPORARY FOR MANUAL TESTING) ---
      # Using dynamic version from previous job for testing
      TAG_NAME="v$(RELEASE_VERSION)-test"
      RELEASE_NAME="Test Release $(RELEASE_VERSION)"
      RELEASE_BODY="This is a test release for version $(RELEASE_VERSION) generated from commit: $last_commit_message"

      # Consider these for safer testing:
      IS_DRAFT="false"        # Creates a draft release on GitHub (not public)
      IS_PRERELEASE="true"   # Marks it as a pre-release
      # --- End of Temporary Configuration ---


      # --- Validate Inputs ---
      if [ -z "$GITHUB_TOKEN" ]; then # Check bash environment variable for GITHUB_TOKEN
        echo "Error: GITHUB_TOKEN is not set or not available as a secret."
        exit 1
      fi
      if [ -z "$DYNAMIC_GITHUB_REPO_OWNER" ]; then # Check dynamically determined owner
        echo "Error: DYNAMIC_GITHUB_REPO_OWNER could not be determined."
        exit 1
      fi
      if [ -z "$DYNAMIC_GITHUB_REPO_NAME" ]; then # Check dynamically determined repo name
        echo "Error: DYNAMIC_GITHUB_REPO_NAME could not be determined."
        exit 1
      fi
      if [ -z "$VERSION" ]; then # Check bash environment variable for VERSION
        echo "Error: VERSION is not set (should come from previous job)."
        exit 1
      fi

      echo "Creating GitHub Release..."
      echo "Repository: ${DYNAMIC_GITHUB_REPO_OWNER}/${DYNAMIC_GITHUB_REPO_NAME}"
      echo "Tag Name: ${TAG_NAME}"
      echo "Release Name: ${RELEASE_NAME}"

      # --- Construct JSON Payload ---
      # Using current commit from the checkout
      TARGET_COMMITISH=$(git rev-parse HEAD)
      echo "Target Commit: ${TARGET_COMMITISH}"

      JSON_PAYLOAD=$(cat <<EOF
      {
        "tag_name": "${TAG_NAME}",
        "target_commitish": "${TARGET_COMMITISH}",
        "name": "${RELEASE_NAME}",
        "body": "${RELEASE_BODY}",
        "draft": ${IS_DRAFT},
        "prerelease": ${IS_PRERELEASE}
      }
      EOF
      )

      echo "Payload:"
      echo "${JSON_PAYLOAD}"

      # --- Make API Call ---
      API_URL="https://api.github.com/repos/${DYNAMIC_GITHUB_REPO_OWNER}/${DYNAMIC_GITHUB_REPO_NAME}/releases"

      response=$(curl -s -w "%{http_code}" \
        -X POST \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Authorization: token $GITHUB_TOKEN" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        -H "Content-Type: application/json" \
        -d "${JSON_PAYLOAD}" \
        "${API_URL}")

      http_code=$(tail -n1 <<< "$response")
      response_body=$(sed '$ d' <<< "$response")

      echo "GitHub API Response Code: ${http_code}"
      # echo "GitHub API Response Body: ${response_body}" # Can be verbose

      if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
        echo "Successfully created GitHub Release: ${RELEASE_NAME}"
        # Output the release URL for information
        release_url=$(echo "$response_body" | grep -oP '"html_url":\s*"\K[^"]*')
        if [ -n "$release_url" ]; then
            echo "Release URL: $release_url"
        fi
      else
        echo "Error: Failed to create GitHub Release."
        echo "Response Code: ${http_code}"
        echo "Response Body (first 500 chars): $(echo "$response_body" | head -c 500)"
        if [[ "$response_body" == *"already_exists"* ]]; then
          echo "This error often indicates that the tag '${TAG_NAME}' already exists."
        fi
        exit 1
      fi
    displayName: 'Execute GitHub Release Script'
    env:
      # Map Azure DevOps pipeline variables (including secrets) to environment variables for the script
      GITHUB_TOKEN: $(GITHUB_TOKEN) # $(GITHUB_TOKEN) is the ADO way to reference the secret
      # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are now determined dynamically within the script
      VERSION: $(RELEASE_VERSION) # Pass the version to the script's expected VERSION env var
      # Map necessary variables from variable group 'pythonrest-cli'
      pypi_app_name: $(pypi_app_name)
      pip_api_key: $(pip_api_key)


# jobs:
# - job: ExtractVersion
#   displayName: '1. Extract Version & Prepare Files'
#   pool:
#     vmImage: ubuntu-latest
#   steps:
#   - checkout: self # Checks out the repository
#     persistCredentials: true # Important for git operations if needed later, and for commit sha
#   - script: |
#       # Ensure we have full commit history in the CI environment
#       git fetch --all --unshallow
      
#       # Find the last non-merge commit before the merge commit (PR source commit)
#       last_commit_message=$(git log -1 --pretty=%s $(git rev-list --no-merges -n 1 HEAD))

#       if [[ $last_commit_message =~ version\ ?([0-9]+\.[0-9]+\.[0-9]+) ]]; then
#         extracted_version="${BASH_REMATCH[1]}"
#         echo "Extracted version: $extracted_version"
#         # Set the output variable for this job, accessible by other jobs in the same stage
#         echo "##vso[task.setvariable variable=packageVersion;isOutput=true]$extracted_version"
#       else
#         echo "Error: The commit message does not contain a valid version format (version X.X.X)."
#         echo "Last commit message: $last_commit_message"
#         exit 1
#       fi
#     displayName: "Check commit message format"

#   - script: |
#       python3 -m venv venv
#       source venv/bin/activate
#       pip install --upgrade pip setuptools wheel
#       python setup.py sdist
#     displayName: 'Validate pip package build'


