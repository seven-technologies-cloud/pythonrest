# trigger:
  # branches:
    # include:
    #  - main
trigger: none
pr:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
- group: pythonrest-cli # This group likely contains pip_api_key, pypi_app_name
# GITHUB_REPO_OWNER and GITHUB_REPO_NAME will now be determined dynamically.
# These can be kept as fallbacks or for reference, but the script will prioritize dynamic values.
# - name: GITHUB_REPO_OWNER
#   value: 'your-github-username-or-org' # Fallback or reference
# - name: GITHUB_REPO_NAME
#   value: 'pythonrest' # Fallback or reference
# GITHUB_TOKEN will be a secret variable, configured in Azure DevOps UI

jobs:
- job: ExtractVersion
  displayName: '1. Extract Version & Prepare Files'
  pool:
    vmImage: ubuntu-latest
  steps:
  - checkout: self # Checks out the repository
    persistCredentials: true # Important for git operations if needed later, and for commit sha
  - script: |
      # Ensure we have full commit history in the CI environment
      git fetch --all --unshallow
      
      # Find the last non-merge commit before the merge commit (PR source commit)
      last_commit_message=$(git log -1 --pretty=%s $(git rev-list --no-merges -n 1 HEAD))

      if [[ $last_commit_message =~ version\ ?([0-9]+\.[0-9]+\.[0-9]+) ]]; then
        extracted_version="${BASH_REMATCH[1]}"
        echo "Extracted version: $extracted_version"
        # Set the output variable for this job, accessible by other jobs in the same stage
        echo "##vso[task.setvariable variable=packageVersion;isOutput=true]$extracted_version"
      else
        echo "Error: The commit message does not contain a valid version format (version X.X.X)."
        echo "Last commit message: $last_commit_message"
        exit 1
      fi

      sed -i "s/version='[0-9]\+\.[0-9]\+\.[0-9]\+'$/version='$extracted_version'/" ./setup.py
      sed -i "s/pythonrest_version = \"[0-9]\+\.[0-9]\+\.[0-9]\+\"/pythonrest_version = \"$extracted_version\"/" ./pythonrest.py
      
      echo "Updated setup.py and pythonrest.py version to $extracted_version"
      
      grep "version=" ./setup.py
      grep "pythonrest_version" ./pythonrest.py
    name: VersionExtractionStep # Step name to reference its output variable

- job: CreateGitHubRelease
  displayName: '2. Create GitHub Release'
  dependsOn: ExtractVersion
  pool:
    vmImage: ubuntu-latest
  variables:
    # Map the output variable from ExtractVersion job to a local variable in this job
    # RELEASE_VERSION: $[ dependencies.ExtractVersion.outputs['VersionExtractionStep.packageVersion'] ]
    RELEASE_VERSION:
    # GITHUB_TOKEN should be a secret pipeline variable (e.g., from a variable group or configured in UI)
    # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are defined at the pipeline level or can be overridden here/passed from group
  steps:
  - checkout: self # Checkout self to ensure git commands work, e.g. git rev-parse HEAD
    persistCredentials: true
  - script: |
      # Script to create a GitHub Release (from previous step)
      # Environment variables expected by this script:
      # GITHUB_TOKEN: (mapped from Azure Pipelines secret $(GITHUB_TOKEN))
      # VERSION: (this is mapped to $(RELEASE_VERSION) which comes from the previous job)
      # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are now determined dynamically within this script.

      echo "--- GitHub Release Script ---"
      echo "Version from previous job: $(RELEASE_VERSION)"

      # --- Determine Repository Owner and Name Dynamically ---
      REPO_FULL_NAME="$(Build.Repository.Name)" # e.g., "your-username/pythonrest"
      DYNAMIC_GITHUB_REPO_OWNER=""
      DYNAMIC_GITHUB_REPO_NAME=""

      if [[ "$(Build.Repository.Provider)" == "GitHub" && "$REPO_FULL_NAME" == */* ]]; then
        DYNAMIC_GITHUB_REPO_OWNER="${REPO_FULL_NAME%/*}"
        DYNAMIC_GITHUB_REPO_NAME="${REPO_FULL_NAME#*/}"
        echo "Dynamically determined GitHub Owner: $DYNAMIC_GITHUB_REPO_OWNER, Repo: $DYNAMIC_GITHUB_REPO_NAME"
      else
        echo "Error: Could not dynamically determine GitHub owner/repo. Provider: '$(Build.Repository.Provider)', Repo Name: '$REPO_FULL_NAME'."
        echo "Ensure pipeline is connected to a GitHub repository and checkout step ran."
        exit 1
      fi

      # --- Configuration (TEMPORARY FOR MANUAL TESTING) ---
      # Comment out or remove these lines:
      # TAG_NAME="v$(RELEASE_VERSION)"
      # RELEASE_NAME="Version $(RELEASE_VERSION)"
      # RELEASE_BODY="Release of version $(RELEASE_VERSION)."

      # Add these lines for manual testing:
      TEST_VERSION="test-release-0.0.1"  # <<< CHANGE THIS FOR EACH TEST RUN
      TAG_NAME="v${TEST_VERSION}"
      RELEASE_NAME="Test Release ${TEST_VERSION}"
      RELEASE_BODY="This is a manual test release for version ${TEST_VERSION}."

      # Consider these for safer testing:
      IS_DRAFT="true"        # Creates a draft release on GitHub (not public)
      IS_PRERELEASE="true"   # Marks it as a pre-release
      # --- End of Temporary Configuration ---


      # --- Validate Inputs ---
      if [ -z "$(GITHUB_TOKEN)" ]; then # Check Azure DevOps variable syntax for GITHUB_TOKEN
        echo "Error: GITHUB_TOKEN is not set or not available as a secret."
        exit 1
      fi
      if [ -z "$DYNAMIC_GITHUB_REPO_OWNER" ]; then # Check dynamically determined owner
        echo "Error: DYNAMIC_GITHUB_REPO_OWNER could not be determined."
        exit 1
      fi
      if [ -z "$DYNAMIC_GITHUB_REPO_NAME" ]; then # Check dynamically determined repo name
        echo "Error: DYNAMIC_GITHUB_REPO_NAME could not be determined."
        exit 1
      fi
      if [ -z "$(RELEASE_VERSION)" ]; then
        echo "Error: RELEASE_VERSION is not set (should come from previous job)."
        exit 1
      fi

      echo "Creating GitHub Release..."
      echo "Repository: ${DYNAMIC_GITHUB_REPO_OWNER}/${DYNAMIC_GITHUB_REPO_NAME}"
      echo "Tag Name: ${TAG_NAME}"
      echo "Release Name: ${RELEASE_NAME}"

      # --- Construct JSON Payload ---
      # Using current commit from the checkout
      TARGET_COMMITISH=$(git rev-parse HEAD)
      echo "Target Commit: ${TARGET_COMMITISH}"

      JSON_PAYLOAD=$(cat <<EOF
      {
        "tag_name": "${TAG_NAME}",
        "target_commitish": "${TARGET_COMMITISH}",
        "name": "${RELEASE_NAME}",
        "body": "${RELEASE_BODY}",
        "draft": ${IS_DRAFT},
        "prerelease": ${IS_PRERELEASE}
      }
      EOF
      )

      echo "Payload:"
      echo "${JSON_PAYLOAD}"

      # --- Make API Call ---
      API_URL="https://api.github.com/repos/${DYNAMIC_GITHUB_REPO_OWNER}/${DYNAMIC_GITHUB_REPO_NAME}/releases"

      response=$(curl -s -w "%{http_code}" \
        -X POST \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Authorization: token $(GITHUB_TOKEN)" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        -H "Content-Type: application/json" \
        -d "${JSON_PAYLOAD}" \
        "${API_URL}")

      http_code=$(tail -n1 <<< "$response")
      response_body=$(sed '$ d' <<< "$response")

      echo "GitHub API Response Code: ${http_code}"
      # echo "GitHub API Response Body: ${response_body}" # Can be verbose

      if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
        echo "Successfully created GitHub Release: ${RELEASE_NAME}"
        # Output the release URL for information
        release_url=$(echo "$response_body" | grep -oP '"html_url":\s*"\K[^"]*')
        if [ -n "$release_url" ]; then
            echo "Release URL: $release_url"
        fi
      else
        echo "Error: Failed to create GitHub Release."
        echo "Response Code: ${http_code}"
        echo "Response Body (first 500 chars): $(echo "$response_body" | head -c 500)"
        if [[ "$response_body" == *"already_exists"* ]]; then
          echo "This error often indicates that the tag '${TAG_NAME}' already exists."
        fi
        exit 1
      fi
    displayName: 'Execute GitHub Release Script'
    env:
      # Map Azure DevOps pipeline variables (including secrets) to environment variables for the script
      GITHUB_TOKEN: $(GITHUB_TOKEN) # $(GITHUB_TOKEN) is the ADO way to reference the secret
      # GITHUB_REPO_OWNER and GITHUB_REPO_NAME are now determined dynamically within the script
      VERSION: $(RELEASE_VERSION) # Pass the version to the script's expected VERSION env var

- job: PublishToPyPi
  displayName: '3. Publish to PyPI'
  dependsOn: CreateGitHubRelease # Depends on the GitHub Release job
  pool:
    vmImage: ubuntu-latest
  variables:
    # Map the output variable from ExtractVersion job
    LOCAL_SETUP_VERSION: $[ dependencies.ExtractVersion.outputs['VersionExtractionStep.packageVersion'] ]
  steps:
  - checkout: self # Need to checkout again to have setup.py and pythonrest.py (which were modified in ExtractVersion)
                  # If ExtractVersion published artifacts, this job could download them instead.
                  # For simplicity, checking out again is fine if modifications are idempotent or source is clean.
                  # The files modified (setup.py, pythonrest.py) are part of the repo, so checkout brings them.
                  # We need to ensure the file modifications from ExtractVersion are present.
                  # A better way would be to pass setup.py and pythonrest.py as artifacts.
                  # For now, re-running the sed commands to ensure file state if checkout is clean.
  - script: |
      echo "Ensuring setup.py and pythonrest.py are updated with version $(LOCAL_SETUP_VERSION)..."
      sed -i "s/version='[0-9]\+\.[0-9]\+\.[0-9]\+'$/version='$(LOCAL_SETUP_VERSION)'/" ./setup.py
      sed -i "s/pythonrest_version = \"[0-9]\+\.[0-9]\+\.[0-9]\+\"/pythonrest_version = \"$(LOCAL_SETUP_VERSION)\"/" ./pythonrest.py

      echo "Updated setup.py and pythonrest.py version to $(LOCAL_SETUP_VERSION) for PyPI job."
      grep "version=" ./setup.py
      grep "pythonrest_version" ./pythonrest.py

      # The rest of the original PyPI publishing script
      latest_version=$(curl -s https://pypi.org/pypi/$(pypi_app_name)/json | jq -r '.info.version' 2>/dev/null || echo "0.0.0")
      echo "Latest version on PyPI: $latest_version"

      # local_version variable is now LOCAL_SETUP_VERSION from the previous job
      echo "Local version for setup.py (from previous job): $(LOCAL_SETUP_VERSION)"

      if [ "$latest_version" != "$(LOCAL_SETUP_VERSION)" ]; then
        echo "Versions are different. Uploading to PyPI."
        pip3 install --upgrade pip
        pip3 install --upgrade packaging twine setuptools wheel
        python3 setup.py sdist bdist_wheel # Build both sdist and wheel
        python3 -m twine upload dist/* --username __token__ --password $(pip_api_key)
      else
        echo "Versions are the same ($(LOCAL_SETUP_VERSION)). Skipping PyPI upload."
      fi
    displayName: 'Check Version and Publish to PyPI'
    env:
      # Map necessary variables from variable group 'pythonrest-cli'
      pypi_app_name: $(pypi_app_name)
      pip_api_key: $(pip_api_key)

# Commented out Chocolatey jobs for brevity, assuming they are not directly affected by this change
# - job: CheckChocoCLIVersion
#   ...
# - job: manual_approval
#   ...
# - job: PublishPackageToChocolatey
#   ...
